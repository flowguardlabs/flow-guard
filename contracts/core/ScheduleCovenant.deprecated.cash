/**
 * ScheduleCovenant — Production Grade
 *
 * ENFORCEABILITY: [ENFORCEABLE-NOW]
 *
 * PURPOSE: Enforces scheduled fund releases for ALL time-based payment products:
 *   - Vesting streams (linear, step)
 *   - Recurring payments (payroll, subscriptions)
 *   - Budget plan disbursements
 *
 * SUPPORTS:
 *   - BCH and CashToken FT vesting
 *   - All schedule types: RECURRING (0), LINEAR_VESTING (1), STEP_VESTING (2)
 *   - Cliff periods
 *   - Pause / Resume (with LINEAR time-accounting correction)
 *   - Cancel with vested/unvested split to recipient/authority
 *   - Transferable streams (recipient can reassign to new address)
 *   - Final unlock (complete)
 *
 * NFT COMMITMENT (40 bytes — within CashTokens 40-byte limit):
 *   [0]:     status (uint8)
 *              0 = ACTIVE
 *              1 = PAUSED
 *              2 = CANCELLED
 *              3 = COMPLETED
 *   [1]:     flags (uint8)
 *              bit0 (value 1) = cancelable
 *              bit1 (value 2) = transferable
 *              bit2 (value 4) = usesTokens (FT vesting, else BCH)
 *   [2-9]:   total_released (uint64 satoshis or FT token amount)
 *   [10-14]: schedule_cursor (5-byte timestamp):
 *              RECURRING / STEP: next_unlock_timestamp
 *              LINEAR:           effective_start (adjusted forward after each pause)
 *   [15-19]: pause_start (5-byte timestamp, 0 if not paused)
 *   [20-39]: recipientHash (bytes20 = hash160 of recipient P2PKH address)
 *
 * CONTRACT PARAMETERS (compiled into bytecode, immutable):
 *   vaultId           — links schedule to source vault
 *   authorityHash     — hash160 of vault P2SH address (controls pause/cancel/resume)
 *   scheduleType      — 0=RECURRING, 1=LINEAR, 2=STEP
 *   intervalSeconds   — seconds between unlocks (RECURRING/STEP)
 *   amountPerInterval — satoshis or FT amount per unlock (RECURRING/STEP)
 *   totalAmount       — total to release (LINEAR; for RECURRING/STEP = total pool)
 *   startTimestamp    — schedule start (used as initial effective_start for LINEAR)
 *   endTimestamp      — schedule end for LINEAR (0 = perpetual RECURRING)
 *   cliffTimestamp    — no claims before this (0 = no cliff)
 *
 * PRE-LAYLA: Fully supported (no iteration needed for single-recipient schedules)
 * POST-LAYLA: No contract changes needed; efficiency improvements possible
 */

pragma cashscript ^0.10.0;

contract ScheduleCovenant(
    bytes32 vaultId,
    bytes20 authorityHash,
    int scheduleType,
    int intervalSeconds,
    int amountPerInterval,
    int totalAmount,
    int startTimestamp,
    int endTimestamp,
    int cliffTimestamp
) {
    // Status constants
    int STATUS_ACTIVE    = 0;
    int STATUS_PAUSED    = 1;
    int STATUS_CANCELLED = 2;
    int STATUS_COMPLETED = 3;

    // Schedule type constants
    int TYPE_RECURRING = 0;
    int TYPE_LINEAR    = 1;
    int TYPE_STEP      = 2;

    // Flag bit values
    int FLAG_CANCELABLE    = 1;  // bit0
    int FLAG_TRANSFERABLE  = 2;  // bit1
    int FLAG_USES_TOKENS   = 4;  // bit2

    /**
     * unlock() — Claim vested or scheduled funds
     *
     * Validates:
     * - Status is ACTIVE
     * - Cliff period respected
     * - Correct claimable amount computed per schedule type
     * - Output[0] goes to correct recipient address with correct amount
     * - Output[1] is updated ScheduleNFT with correct state
     */
    function unlock() {
        bytes c = tx.inputs[0].nftCommitment;

        int status        = int(c[0:1]);
        int flags         = int(c[1:2]);
        int totalReleased = int(c[2:10]);
        int cursor        = int(c[10:15]);
        bytes20 recipient = bytes20(c[20:40]);

        // Must be active
        require(status == STATUS_ACTIVE);

        // Cliff must be passed
        if (cliffTimestamp > 0) {
            require(tx.locktime >= cliffTimestamp);
        }

        // Compute payout and new cursor
        int payout    = 0;
        int newCursor = cursor;

        if (scheduleType == TYPE_RECURRING) {
            require(tx.locktime >= cursor);
            payout    = amountPerInterval;
            newCursor = cursor + intervalSeconds;

        } else if (scheduleType == TYPE_LINEAR) {
            // cursor = effective_start (adjusted for pauses)
            int elapsed  = tx.locktime - cursor;
            int duration = endTimestamp - cursor;
            require(duration > 0);
            require(elapsed > 0);

            int maxVested = totalAmount * elapsed / duration;
            if (maxVested > totalAmount) {
                maxVested = totalAmount;
            }
            payout = maxVested - totalReleased;
            require(payout > 0);
            newCursor = cursor; // effective_start does not change on regular unlock

        } else if (scheduleType == TYPE_STEP) {
            require(tx.locktime >= cursor);
            payout    = amountPerInterval;
            newCursor = cursor + intervalSeconds;
        }

        // Verify recipient output
        require(tx.outputs[0].lockingBytecode == new LockingBytecodeP2PKH(recipient));

        if (flags & FLAG_USES_TOKENS == FLAG_USES_TOKENS) {
            // CashToken FT path: verify token amount, BCH covers dust only
            require(tx.outputs[0].tokenCategory == tx.inputs[0].tokenCategory);
            require(tx.outputs[0].tokenAmount == payout);
        } else {
            // BCH path
            require(tx.outputs[0].value == payout);
        }

        // Determine if schedule is now complete
        int newTotalReleased = totalReleased + payout;
        int newStatus        = STATUS_ACTIVE;
        if (scheduleType == TYPE_LINEAR || scheduleType == TYPE_STEP) {
            if (newTotalReleased >= totalAmount) {
                newStatus = STATUS_COMPLETED;
            }
        }

        // Build updated commitment
        bytes newCommitment =
            bytes1(newStatus) +
            c[1:2] +                   // preserve flags
            bytes8(newTotalReleased) +
            bytes5(newCursor) +
            bytes5(0) +                // pause_start = 0 (active)
            recipient;

        require(tx.outputs[1].nftCommitment == newCommitment);
        require(tx.outputs[1].tokenCategory == tx.inputs[0].tokenCategory);
    }

    /**
     * complete() — Final claim when schedule is fully vested
     *
     * Burns the ScheduleNFT after releasing the last amount.
     * Valid for LINEAR and STEP (RECURRING uses regular unlock).
     */
    function complete() {
        bytes c = tx.inputs[0].nftCommitment;

        int status        = int(c[0:1]);
        int flags         = int(c[1:2]);
        int totalReleased = int(c[2:10]);
        bytes20 recipient = bytes20(c[20:40]);

        require(status == STATUS_ACTIVE || status == STATUS_COMPLETED);
        require(scheduleType == TYPE_LINEAR || scheduleType == TYPE_STEP);

        // For LINEAR: must be past end time
        if (scheduleType == TYPE_LINEAR) {
            require(tx.locktime >= endTimestamp);
        }

        int finalPayout = totalAmount - totalReleased;
        require(finalPayout > 0);

        require(tx.outputs[0].lockingBytecode == new LockingBytecodeP2PKH(recipient));

        if (flags & FLAG_USES_TOKENS == FLAG_USES_TOKENS) {
            require(tx.outputs[0].tokenCategory == tx.inputs[0].tokenCategory);
            require(tx.outputs[0].tokenAmount == finalPayout);
        } else {
            require(tx.outputs[0].value == finalPayout);
        }

        // ScheduleNFT is consumed (no NFT output = burned)
    }

    /**
     * pause() — Pause the schedule
     *
     * Authority-only. Only if cancelable flag set.
     * Records pause_start timestamp for accurate LINEAR time accounting.
     */
    function pause(sig authSig, pubkey authPubkey) {
        bytes c = tx.inputs[0].nftCommitment;

        int status = int(c[0:1]);
        int flags  = int(c[1:2]);

        require(hash160(authPubkey) == authorityHash);
        require(checkSig(authSig, authPubkey));

        // Only cancelable streams can be paused
        require(flags & FLAG_CANCELABLE == FLAG_CANCELABLE);
        require(status == STATUS_ACTIVE);

        bytes newCommitment =
            bytes1(STATUS_PAUSED) +
            c[1:10] +                  // preserve flags + total_released
            c[10:15] +                 // preserve cursor
            bytes5(tx.locktime) +      // record when paused
            bytes20(c[20:40]);         // preserve recipient

        require(tx.outputs[0].nftCommitment == newCommitment);
        require(tx.outputs[0].tokenCategory == tx.inputs[0].tokenCategory);
    }

    /**
     * resume() — Resume a paused schedule
     *
     * For LINEAR vesting: shifts effective_start forward by the pause duration
     * so the recipient does not lose vesting time while paused.
     */
    function resume(sig authSig, pubkey authPubkey) {
        bytes c = tx.inputs[0].nftCommitment;

        int status     = int(c[0:1]);
        int cursor     = int(c[10:15]);
        int pauseStart = int(c[15:20]);

        require(hash160(authPubkey) == authorityHash);
        require(checkSig(authSig, authPubkey));

        require(status == STATUS_PAUSED);
        require(pauseStart > 0);

        // Shift effective_start forward by pause duration for LINEAR
        int newCursor = cursor;
        if (scheduleType == TYPE_LINEAR) {
            int pauseDuration = tx.locktime - pauseStart;
            newCursor = cursor + pauseDuration;
        }

        bytes newCommitment =
            bytes1(STATUS_ACTIVE) +
            c[1:10] +                  // preserve flags + total_released
            bytes5(newCursor) +        // updated cursor
            bytes5(0) +                // clear pause_start
            bytes20(c[20:40]);         // preserve recipient

        require(tx.outputs[0].nftCommitment == newCommitment);
        require(tx.outputs[0].tokenCategory == tx.inputs[0].tokenCategory);
    }

    /**
     * cancel() — Cancel the schedule and split remaining funds
     *
     * Vested-but-unclaimed → recipient
     * Unvested remainder → authority (vault)
     *
     * Authority-only. Only if cancelable flag set.
     * Works from ACTIVE or PAUSED state.
     */
    function cancel(sig authSig, pubkey authPubkey) {
        bytes c = tx.inputs[0].nftCommitment;

        int status        = int(c[0:1]);
        int flags         = int(c[1:2]);
        int totalReleased = int(c[2:10]);
        int cursor        = int(c[10:15]);
        int pauseStart    = int(c[15:20]);
        bytes20 recipient = bytes20(c[20:40]);

        require(hash160(authPubkey) == authorityHash);
        require(checkSig(authSig, authPubkey));

        require(flags & FLAG_CANCELABLE == FLAG_CANCELABLE);
        require(status == STATUS_ACTIVE || status == STATUS_PAUSED);

        // For paused LINEAR: use pause_start as "current time" for vesting calc
        int evalTime = tx.locktime;
        if (status == STATUS_PAUSED && pauseStart > 0) {
            evalTime = pauseStart;
        }

        // Compute how much has vested at cancel time
        int vestedAtCancel = 0;
        if (scheduleType == TYPE_LINEAR) {
            int elapsed  = evalTime - cursor;
            int duration = endTimestamp - cursor;
            if (elapsed >= duration) {
                vestedAtCancel = totalAmount;
            } else if (elapsed > 0 && duration > 0) {
                vestedAtCancel = totalAmount * elapsed / duration;
            }
        } else {
            // RECURRING/STEP: vested = whatever has been unlocked so far
            vestedAtCancel = totalReleased;
        }

        int recipientPayout = vestedAtCancel - totalReleased;
        int authorityRefund = totalAmount - vestedAtCancel;

        // Output to recipient (vested but unclaimed)
        if (recipientPayout > 0) {
            require(tx.outputs[0].lockingBytecode == new LockingBytecodeP2PKH(recipient));
            if (flags & FLAG_USES_TOKENS == FLAG_USES_TOKENS) {
                require(tx.outputs[0].tokenCategory == tx.inputs[0].tokenCategory);
                require(tx.outputs[0].tokenAmount == recipientPayout);
            } else {
                require(tx.outputs[0].value == recipientPayout);
            }
        }

        // Output to authority (unvested refund)
        if (authorityRefund > 0) {
            require(tx.outputs[1].lockingBytecode == new LockingBytecodeP2SH20(authorityHash));
            if (flags & FLAG_USES_TOKENS == FLAG_USES_TOKENS) {
                require(tx.outputs[1].tokenCategory == tx.inputs[0].tokenCategory);
                require(tx.outputs[1].tokenAmount == authorityRefund);
            } else {
                require(tx.outputs[1].value == authorityRefund);
            }
        }

        // ScheduleNFT burned (no NFT output)
    }

    /**
     * transfer() — Reassign the stream to a new recipient
     *
     * Requires current recipient's signature.
     * Only allowed if transferable flag is set.
     * Updates recipientHash in commitment.
     */
    function transfer(sig recipientSig, pubkey recipientPubkey, bytes20 newRecipientHash) {
        bytes c = tx.inputs[0].nftCommitment;

        int status      = int(c[0:1]);
        int flags       = int(c[1:2]);
        bytes20 current = bytes20(c[20:40]);

        require(hash160(recipientPubkey) == current);
        require(checkSig(recipientSig, recipientPubkey));

        require(flags & FLAG_TRANSFERABLE == FLAG_TRANSFERABLE);
        require(status == STATUS_ACTIVE);

        // New commitment with updated recipient, all state preserved
        bytes newCommitment = c[0:20] + newRecipientHash;

        require(tx.outputs[0].nftCommitment == newCommitment);
        require(tx.outputs[0].tokenCategory == tx.inputs[0].tokenCategory);
    }
}
