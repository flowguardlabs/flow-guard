/**
 * AirdropCovenant — Production Grade
 *
 * ENFORCEABILITY: [ENFORCEABLE-NOW]
 *
 * PURPOSE: Enforce mass token/BCH distribution campaigns.
 *          Claims require both claimer signature AND claim-authority co-signature.
 *          The claim-authority is a backend-held key that enforces eligibility and
 *          per-address limits off-chain before co-signing.
 *          Authority (admin key) controls administrative paths (pause/resume/cancel).
 *
 * NFT COMMITMENT (40 bytes — within CashTokens 40-byte limit):
 *   [0]:     status (uint8: 0=ACTIVE, 1=PAUSED, 2=CANCELLED, 3=COMPLETED)
 *   [1]:     flags (uint8: bit0=cancelable, bit2=usesTokens)
 *   [2-9]:   total_claimed (uint64)
 *   [10-17]: claims_count (uint64)
 *   [18-22]: last_claim_timestamp (5 bytes)
 *   [23-39]: reserved (17 bytes)
 *
 * CONTRACT PARAMETERS (compiled into bytecode, immutable):
 *   vaultId            — links campaign to source vault
 *   authorityHash      — hash160(authority pubkey) used for pause/resume/cancel
 *   claimAuthorityHash — hash160(claimAuthority pubkey); backend co-signs each claim
 *                        to enforce eligibility and per-address limits
 *   amountPerClaim     — satoshis or FT per claim (fixed)
 *   totalPool          — total amount available
 *   startTimestamp     — when claims open (0 = immediate)
 *   endTimestamp       — when claims close (0 = no expiry)
 */

pragma cashscript ^0.13.0;

contract AirdropCovenant(
    bytes32 vaultId,
    bytes20 authorityHash,
    bytes20 claimAuthorityHash,
    int amountPerClaim,
    int totalPool,
    int startTimestamp,
    int endTimestamp
) {
    function claim(
        sig claimerSig, pubkey claimerPubkey, bytes20 claimerHash,
        sig claimAuthSig, pubkey claimAuthPubkey
    ) {
        bytes c = tx.inputs[0].nftCommitment;
        int status       = int(c.split(1)[0]);
        bytes1 flagsByte = c.split(1)[1].split(1)[0];
        int totalClaimed = int(c.split(2)[1].split(8)[0]);
        int claimsCount  = int(c.split(10)[1].split(8)[0]);

        require(hash160(claimerPubkey) == claimerHash);
        require(checkSig(claimerSig, claimerPubkey));
        // Claim-authority co-signature: backend validates eligibility + per-address limit
        require(hash160(claimAuthPubkey) == claimAuthorityHash);
        require(checkSig(claimAuthSig, claimAuthPubkey));
        require(status == 0); // ACTIVE

        if (startTimestamp > 0) { require(tx.locktime >= startTimestamp); }
        if (endTimestamp > 0)   { require(tx.locktime <= endTimestamp); }

        int newTotalClaimed = totalClaimed + amountPerClaim;
        require(newTotalClaimed <= totalPool);

        require(tx.outputs[0].lockingBytecode == new LockingBytecodeP2PKH(claimerHash));

        if ((flagsByte & 0x04) == 0x04) {
            require(tx.outputs[0].tokenCategory == tx.inputs[0].tokenCategory);
            require(tx.outputs[0].tokenAmount == amountPerClaim);
        } else {
            require(tx.outputs[0].value == amountPerClaim);
        }

        int newClaimsCount = claimsCount + 1;
        int newStatus = 0;
        if (newTotalClaimed >= totalPool) { newStatus = 3; } // COMPLETED

        bytes newCommitment =
            toPaddedBytes(newStatus, 1) +
            flagsByte +
            toPaddedBytes(newTotalClaimed, 8) +
            toPaddedBytes(newClaimsCount, 8) +
            toPaddedBytes(tx.locktime, 5) +
            0x0000000000000000000000000000000000;

        require(tx.outputs[1].nftCommitment == newCommitment);
        require(tx.outputs[1].tokenCategory == tx.inputs[0].tokenCategory);
        require(tx.outputs[1].lockingBytecode == tx.inputs[0].lockingBytecode);
        require(vaultId != 0x0000000000000000000000000000000000000000000000000000000000000000);
    }

    function pause(sig authSig, pubkey authPubkey) {
        bytes c = tx.inputs[0].nftCommitment;
        int status       = int(c.split(1)[0]);
        bytes1 flagsByte = c.split(1)[1].split(1)[0];

        require(hash160(authPubkey) == authorityHash);
        require(checkSig(authSig, authPubkey));
        require((flagsByte & 0x01) == 0x01); // cancelable
        require(status == 0); // ACTIVE

        bytes newCommitment =
            0x01 +
            c.split(1)[1].split(22)[0] +
            0x0000000000000000000000000000000000;

        require(tx.outputs[0].nftCommitment == newCommitment);
        require(tx.outputs[0].tokenCategory == tx.inputs[0].tokenCategory);
        require(tx.outputs[0].lockingBytecode == tx.inputs[0].lockingBytecode);
    }

    function resume(sig authSig, pubkey authPubkey) {
        bytes c = tx.inputs[0].nftCommitment;
        int status = int(c.split(1)[0]);

        require(hash160(authPubkey) == authorityHash);
        require(checkSig(authSig, authPubkey));
        require(status == 1); // PAUSED

        bytes newCommitment =
            0x00 +
            c.split(1)[1].split(22)[0] +
            0x0000000000000000000000000000000000;

        require(tx.outputs[0].nftCommitment == newCommitment);
        require(tx.outputs[0].tokenCategory == tx.inputs[0].tokenCategory);
        require(tx.outputs[0].lockingBytecode == tx.inputs[0].lockingBytecode);
    }

    function cancel(sig authSig, pubkey authPubkey) {
        bytes c = tx.inputs[0].nftCommitment;
        int status       = int(c.split(1)[0]);
        bytes1 flagsByte = c.split(1)[1].split(1)[0];
        int totalClaimed = int(c.split(2)[1].split(8)[0]);

        require(hash160(authPubkey) == authorityHash);
        require(checkSig(authSig, authPubkey));
        require((flagsByte & 0x01) == 0x01); // cancelable
        require(status == 0 || status == 1); // ACTIVE or PAUSED

        int remainingPool = totalPool - totalClaimed;
        require(remainingPool > 0);

        require(tx.outputs[0].lockingBytecode == new LockingBytecodeP2PKH(authorityHash));

        if ((flagsByte & 0x04) == 0x04) {
            require(tx.outputs[0].tokenCategory == tx.inputs[0].tokenCategory);
            require(tx.outputs[0].tokenAmount == remainingPool);
        } else {
            require(tx.outputs[0].value == remainingPool);
        }
    }
}
