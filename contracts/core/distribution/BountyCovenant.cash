/**
 * BountyCovenant — Production Grade
 *
 * ENFORCEABILITY: [ENFORCEABLE-NOW]
 *
 * PURPOSE: Enforce proof-based bounty competition payouts.
 *          Contestants submit work proofs. Authority verifies off-chain,
 *          co-signs valid claims. First maxWinners claimants win.
 *
 * NFT COMMITMENT (40 bytes — within CashTokens 40-byte limit):
 *   [0]:     status (uint8: 0=ACTIVE, 1=PAUSED, 2=CANCELLED, 3=COMPLETED)
 *   [1]:     flags (uint8: bit0=cancelable, bit2=usesTokens)
 *   [2-9]:   total_paid (uint64)
 *   [10-13]: winners_count (uint32)
 *   [14-18]: last_claim_timestamp (5 bytes)
 *   [19-39]: reserved (21 bytes)
 *
 * CONTRACT PARAMETERS (compiled into bytecode, immutable):
 *   vaultId         — links bounty to source vault
 *   authorityHash   — hash160(authority pubkey)
 *   rewardPerWinner — satoshis or FT per winner (fixed equal prize)
 *   maxWinners      — maximum number of prizes available
 *   startTimestamp  — when competition opens (0 = immediate)
 *   endTimestamp    — competition deadline (0 = no deadline)
 */

pragma cashscript ^0.13.0;

contract BountyCovenant(
    bytes32 vaultId,
    bytes20 authorityHash,
    int rewardPerWinner,
    int maxWinners,
    int startTimestamp,
    int endTimestamp
) {
    function claim(sig authSig, pubkey authPubkey, bytes20 winnerHash, bytes32 proofHash) {
        bytes c = tx.inputs[0].nftCommitment;
        int status       = int(c.split(1)[0]);
        bytes1 flagsByte = c.split(1)[1].split(1)[0];
        int totalPaid    = int(c.split(2)[1].split(8)[0]);
        int winnersCount = int(c.split(10)[1].split(4)[0]);

        require(hash160(authPubkey) == authorityHash);
        require(checkSig(authSig, authPubkey));
        require(status == 0); // ACTIVE

        if (startTimestamp > 0) { require(tx.locktime >= startTimestamp); }
        if (endTimestamp > 0)   { require(tx.locktime <= endTimestamp); }

        require(winnersCount < maxWinners);
        require(proofHash != 0x0000000000000000000000000000000000000000000000000000000000000000);

        int newTotalPaid    = totalPaid + rewardPerWinner;
        int newWinnersCount = winnersCount + 1;

        require(tx.outputs[0].lockingBytecode == new LockingBytecodeP2PKH(winnerHash));

        if ((flagsByte & 0x04) == 0x04) {
            require(tx.outputs[0].tokenCategory == tx.inputs[0].tokenCategory);
            require(tx.outputs[0].tokenAmount == rewardPerWinner);
        } else {
            require(tx.outputs[0].value == rewardPerWinner);
        }

        int newStatus = 0;
        if (newWinnersCount >= maxWinners) { newStatus = 3; } // COMPLETED

        bytes newCommitment =
            toPaddedBytes(newStatus, 1) +
            flagsByte +
            toPaddedBytes(newTotalPaid, 8) +
            toPaddedBytes(newWinnersCount, 4) +
            toPaddedBytes(tx.locktime, 5) +
            0x000000000000000000000000000000000000000000;

        require(tx.outputs[1].nftCommitment == newCommitment);
        require(tx.outputs[1].tokenCategory == tx.inputs[0].tokenCategory);
        require(tx.outputs[1].lockingBytecode == tx.inputs[0].lockingBytecode);
        require(vaultId != 0x0000000000000000000000000000000000000000000000000000000000000000);
    }

    function pause(sig authSig, pubkey authPubkey) {
        bytes c = tx.inputs[0].nftCommitment;
        int status       = int(c.split(1)[0]);
        bytes1 flagsByte = c.split(1)[1].split(1)[0];

        require(hash160(authPubkey) == authorityHash);
        require(checkSig(authSig, authPubkey));
        require((flagsByte & 0x01) == 0x01);
        require(status == 0); // ACTIVE

        bytes newCommitment =
            0x01 +
            c.split(1)[1].split(18)[0] +
            0x000000000000000000000000000000000000000000;

        require(tx.outputs[0].nftCommitment == newCommitment);
        require(tx.outputs[0].tokenCategory == tx.inputs[0].tokenCategory);
        require(tx.outputs[0].lockingBytecode == tx.inputs[0].lockingBytecode);
    }

    function resume(sig authSig, pubkey authPubkey) {
        bytes c = tx.inputs[0].nftCommitment;
        int status = int(c.split(1)[0]);

        require(hash160(authPubkey) == authorityHash);
        require(checkSig(authSig, authPubkey));
        require(status == 1); // PAUSED

        bytes newCommitment =
            0x00 +
            c.split(1)[1].split(18)[0] +
            0x000000000000000000000000000000000000000000;

        require(tx.outputs[0].nftCommitment == newCommitment);
        require(tx.outputs[0].tokenCategory == tx.inputs[0].tokenCategory);
        require(tx.outputs[0].lockingBytecode == tx.inputs[0].lockingBytecode);
    }

    function cancel(sig authSig, pubkey authPubkey) {
        bytes c = tx.inputs[0].nftCommitment;
        int status       = int(c.split(1)[0]);
        bytes1 flagsByte = c.split(1)[1].split(1)[0];
        int winnersCount = int(c.split(10)[1].split(4)[0]);

        require(hash160(authPubkey) == authorityHash);
        require(checkSig(authSig, authPubkey));
        require((flagsByte & 0x01) == 0x01);
        require(status == 0 || status == 1);

        int remainingPrizes = maxWinners - winnersCount;
        require(remainingPrizes > 0);
        int remainingPool = remainingPrizes * rewardPerWinner;

        require(tx.outputs[0].lockingBytecode == new LockingBytecodeP2PKH(authorityHash));

        if ((flagsByte & 0x04) == 0x04) {
            require(tx.outputs[0].tokenCategory == tx.inputs[0].tokenCategory);
            require(tx.outputs[0].tokenAmount == remainingPool);
        } else {
            require(tx.outputs[0].value == remainingPool);
        }
    }
}
