/**
 * RecurringPaymentCovenant — Production Grade
 *
 * ENFORCEABILITY: [ENFORCEABLE-NOW]
 *
 * PURPOSE: Enforce fixed-interval recurring payments.
 *          Payroll, subscriptions, allowances.
 *          Permissionless pay() — anyone can trigger when interval elapsed.
 *
 * NFT COMMITMENT (40 bytes — within CashTokens 40-byte limit):
 *   [0]:     status (uint8: 0=ACTIVE, 1=PAUSED, 2=CANCELLED, 3=COMPLETED)
 *   [1]:     flags (uint8: bit0=cancelable, bit2=usesTokens)
 *   [2-9]:   total_paid (uint64)
 *   [10-17]: payment_count (uint64)
 *   [18-22]: next_payment_timestamp (5 bytes)
 *   [23-27]: pause_start (5 bytes, when current pause began; 0 if not paused)
 *   [28-39]: reserved (12 bytes)
 *
 * CONTRACT PARAMETERS (compiled into bytecode, immutable):
 *   vaultId         — links to source vault
 *   senderHash      — hash160(sender pubkey) (controls pause/cancel)
 *   recipientHash   — hash160 of recipient P2PKH (fixed)
 *   amountPerInterval — satoshis or FT per payment
 *   intervalSeconds — seconds between payments
 *   totalAmount     — total pool (0 = unlimited until cancelled)
 *   startTimestamp  — when first payment can occur
 *   endTimestamp    — when stream expires (0 = no expiry)
 */

pragma cashscript ^0.13.0;

contract RecurringPaymentCovenant(
    bytes32 vaultId,
    bytes20 senderHash,
    bytes20 recipientHash,
    int amountPerInterval,
    int intervalSeconds,
    int totalAmount,
    int startTimestamp,
    int endTimestamp
) {
    /**
     * pay() — Execute one payment interval
     *
     * Permissionless: executor network can trigger when interval elapsed.
     * Advances next_payment_timestamp by one interval.
     */
    function pay() {
        bytes c = tx.inputs[0].nftCommitment;
        int status         = int(c.split(1)[0]);
        bytes1 flagsByte   = c.split(1)[1].split(1)[0];
        int totalPaid      = int(c.split(2)[1].split(8)[0]);
        int paymentCount   = int(c.split(10)[1].split(8)[0]);
        int nextPayment    = int(c.split(18)[1].split(5)[0]);

        require(status == 0); // ACTIVE
        require(tx.locktime >= nextPayment);

        if (startTimestamp > 0) { require(tx.locktime >= startTimestamp); }
        if (endTimestamp > 0)   { require(tx.locktime <= endTimestamp); }

        int newTotalPaid = totalPaid + amountPerInterval;
        if (totalAmount > 0) { require(newTotalPaid <= totalAmount); }

        require(tx.outputs[0].lockingBytecode == new LockingBytecodeP2PKH(recipientHash));

        if ((flagsByte & 0x04) == 0x04) {
            require(tx.outputs[0].tokenCategory == tx.inputs[0].tokenCategory);
            require(tx.outputs[0].tokenAmount == amountPerInterval);
        } else {
            require(tx.outputs[0].value == amountPerInterval);
        }

        int newPaymentCount   = paymentCount + 1;
        int newNextPayment    = nextPayment + intervalSeconds;
        int newStatus = 0;
        if (totalAmount > 0) {
            if (newTotalPaid >= totalAmount) { newStatus = 3; } // COMPLETED
        }

        bytes newCommitment =
            toPaddedBytes(newStatus, 1) +
            flagsByte +
            toPaddedBytes(newTotalPaid, 8) +
            toPaddedBytes(newPaymentCount, 8) +
            toPaddedBytes(newNextPayment, 5) +
            0x0000000000 +
            0x000000000000000000000000;

        require(tx.outputs[1].nftCommitment == newCommitment);
        require(tx.outputs[1].tokenCategory == tx.inputs[0].tokenCategory);
        require(tx.outputs[1].lockingBytecode == tx.inputs[0].lockingBytecode);
        require(vaultId != 0x0000000000000000000000000000000000000000000000000000000000000000);
    }

    /**
     * pause() — Pause recurring payments
     *
     * Sender-only. Records pause_start.
     */
    function pause(sig senderSig, pubkey senderPubkey) {
        bytes c = tx.inputs[0].nftCommitment;
        int status       = int(c.split(1)[0]);
        bytes1 flagsByte = c.split(1)[1].split(1)[0];

        require(hash160(senderPubkey) == senderHash);
        require(checkSig(senderSig, senderPubkey));
        require((flagsByte & 0x01) == 0x01);
        require(status == 0); // ACTIVE

        bytes newCommitment =
            0x01 +
            flagsByte +
            c.split(2)[1].split(16)[0] +
            toPaddedBytes(tx.locktime, 5) +
            0x000000000000000000000000;

        require(tx.outputs[0].nftCommitment == newCommitment);
        require(tx.outputs[0].tokenCategory == tx.inputs[0].tokenCategory);
        require(tx.outputs[0].lockingBytecode == tx.inputs[0].lockingBytecode);
    }

    /**
     * resume() — Resume recurring payments
     *
     * Resets next_payment to now + interval (no backdated missed payments).
     */
    function resume(sig senderSig, pubkey senderPubkey) {
        bytes c = tx.inputs[0].nftCommitment;
        int status = int(c.split(1)[0]);
        bytes1 flagsByte = c.split(1)[1].split(1)[0];

        require(hash160(senderPubkey) == senderHash);
        require(checkSig(senderSig, senderPubkey));
        require(status == 1); // PAUSED

        int newNextPayment = tx.locktime + intervalSeconds;

        bytes newCommitment =
            0x00 +
            flagsByte +
            c.split(2)[1].split(8)[0] +
            c.split(10)[1].split(8)[0] +
            toPaddedBytes(newNextPayment, 5) +
            0x0000000000 +
            0x000000000000000000000000;

        require(tx.outputs[0].nftCommitment == newCommitment);
        require(tx.outputs[0].tokenCategory == tx.inputs[0].tokenCategory);
        require(tx.outputs[0].lockingBytecode == tx.inputs[0].lockingBytecode);
    }

    /**
     * cancel() — Cancel and return remaining pool to sender
     *
     * Sender-only. Entire remaining pool returns (no split — not earned like vesting).
     */
    function cancel(sig senderSig, pubkey senderPubkey) {
        bytes c = tx.inputs[0].nftCommitment;
        int status     = int(c.split(1)[0]);
        bytes1 flagsByte = c.split(1)[1].split(1)[0];
        int totalPaid  = int(c.split(2)[1].split(8)[0]);

        require(hash160(senderPubkey) == senderHash);
        require(checkSig(senderSig, senderPubkey));
        require((flagsByte & 0x01) == 0x01);
        require(status == 0 || status == 1);

        // For unlimited streams (totalAmount == 0), any remaining BCH is returned
        int remainingPool = 0;
        if (totalAmount > 0) {
            remainingPool = totalAmount - totalPaid;
        }

        if (remainingPool > 0) {
            require(tx.outputs[0].lockingBytecode == new LockingBytecodeP2PKH(senderHash));
            if ((flagsByte & 0x04) == 0x04) {
                require(tx.outputs[0].tokenCategory == tx.inputs[0].tokenCategory);
                require(tx.outputs[0].tokenAmount == remainingPool);
            } else {
                require(tx.outputs[0].value == remainingPool);
            }
        }
    }
}
