/**
 * VaultCovenant — Production Grade
 *
 * ENFORCEABILITY: [ENFORCEABLE-NOW]
 *
 * PURPOSE: Main treasury enforcement covenant
 * - Enforces M-of-N approval for spending
 * - Enforces period spending cap
 * - Recipient allowlist (optional)
 * - Pause by any vault signer (safety-first)
 * - Emergency lock requires all 3 signers
 * - Resume after pause requires M-of-N
 *
 * NFT COMMITMENT (32 bytes — within CashTokens 40-byte limit):
 *   [0]:     version (uint8)
 *   [1]:     status (uint8: 0=ACTIVE, 1=PAUSED, 2=EMERGENCY_LOCK, 3=MIGRATING)
 *   [2-4]:   rolesMask (3 bytes)
 *   [5-8]:   current_period_id (uint32)
 *   [9-16]:  spent_this_period (uint64)
 *   [17-24]: last_update_timestamp (uint64)
 *   [25-31]: reserved
 *
 * CONTRACT PARAMETERS (compiled into bytecode, immutable):
 *   vaultId           — unique vault identifier
 *   requiredApprovals — M in M-of-N
 *   signer1Hash       — hash160 of signer 1 pubkey
 *   signer2Hash       — hash160 of signer 2 pubkey
 *   signer3Hash       — hash160 of signer 3 pubkey
 *   periodDuration    — seconds per spending period
 *   periodCap         — max satoshis per period (0 = unlimited)
 *   recipientCap      — max satoshis per recipient per tx (0 = unlimited)
 *   allowlistEnabled  — 1 = enforce recipient allowlist
 *   allowedAddr1      — allowlist address 1
 *   allowedAddr2      — allowlist address 2
 *   allowedAddr3      — allowlist address 3
 *
 * PRE-LAYLA: Hardcoded max 3-of-3
 * POST-LAYLA: Loops CHIP enables arbitrary M-of-N
 */

pragma cashscript ^0.13.0;

contract VaultCovenant(
    bytes32 vaultId,
    int requiredApprovals,
    bytes20 signer1Hash,
    bytes20 signer2Hash,
    bytes20 signer3Hash,
    int periodDuration,
    int periodCap,
    int recipientCap,
    int allowlistEnabled,
    bytes20 allowedAddr1,
    bytes20 allowedAddr2,
    bytes20 allowedAddr3
) {
    /**
     * unlockPeriod() — Roll treasury accounting period forward without spending funds.
     * Any registered signer can perform this once periodDuration has elapsed.
     */
    function unlockPeriod(
        sig authSig, pubkey authPubkey,
        int newPeriodId,
        int newSpent
    ) {
        bytes c = tx.inputs[0].nftCommitment;
        int status          = int(c.split(1)[1].split(1)[0]);
        int currentPeriodId = int(c.split(5)[1].split(4)[0]);
        int lastUpdateTime  = int(c.split(17)[1].split(8)[0]);

        bytes20 authHash = hash160(authPubkey);
        require(authHash == signer1Hash || authHash == signer2Hash || authHash == signer3Hash);
        require(checkSig(authSig, authPubkey));
        require(status == 0); // ACTIVE

        require(newPeriodId > currentPeriodId);
        require(newSpent == 0);

        if (periodDuration > 0) {
            int requiredLocktime = lastUpdateTime + ((newPeriodId - currentPeriodId) * periodDuration);
            require(tx.locktime >= requiredLocktime);
        }

        bytes newCommitment =
            c.split(1)[0] +
            0x00 +
            c.split(2)[1].split(3)[0] +
            toPaddedBytes(newPeriodId, 4) +
            toPaddedBytes(newSpent, 8) +
            toPaddedBytes(tx.locktime, 8) +
            0x0000000000000000000000000000;

        int feeDelta = tx.inputs[0].value - tx.outputs[0].value;
        require(feeDelta >= 0 && feeDelta <= 2000); // allow paying miner fee from treasury UTXO

        require(tx.outputs[0].nftCommitment == newCommitment);
        require(tx.outputs[0].tokenCategory == tx.inputs[0].tokenCategory);
        require(tx.outputs[0].lockingBytecode == tx.inputs[0].lockingBytecode);
    }

    /**
     * spend() — Execute a spending proposal with M-of-N approval
     */
    function spend(
        sig sig1, pubkey pubkey1,
        sig sig2, pubkey pubkey2,
        bytes32 proposalId,
        bytes20 recipientHash,
        int payoutAmount,
        int newPeriodId,
        int newSpent
    ) {
        bytes c = tx.inputs[0].nftCommitment;
        int status          = int(c.split(1)[1].split(1)[0]);
        int currentPeriodId = int(c.split(5)[1].split(4)[0]);
        int spentThisPeriod = int(c.split(9)[1].split(8)[0]);
        int lastUpdateTime  = int(c.split(17)[1].split(8)[0]);

        require(status == 0); // ACTIVE

        bytes20 pk1Hash = hash160(pubkey1);
        bytes20 pk2Hash = hash160(pubkey2);

        require(pk1Hash == signer1Hash || pk1Hash == signer2Hash || pk1Hash == signer3Hash);
        require(pk2Hash == signer1Hash || pk2Hash == signer2Hash || pk2Hash == signer3Hash);
        require(pk1Hash != pk2Hash);

        require(checkSig(sig1, pubkey1));
        require(checkSig(sig2, pubkey2));

        if (newPeriodId > currentPeriodId) {
            // Period rollover only valid if enough time elapsed
            if (periodDuration > 0) { require(tx.locktime >= lastUpdateTime + periodDuration); }
            require(newSpent == payoutAmount);
        } else {
            require(newSpent == spentThisPeriod + payoutAmount);
        }

        if (periodCap > 0) { require(newSpent <= periodCap); }
        if (recipientCap > 0) { require(payoutAmount <= recipientCap); }

        if (allowlistEnabled == 1) {
            require(
                recipientHash == allowedAddr1 ||
                recipientHash == allowedAddr2 ||
                recipientHash == allowedAddr3
            );
        }

        require(tx.outputs[0].lockingBytecode == new LockingBytecodeP2PKH(recipientHash));
        require(tx.outputs[0].value == payoutAmount);

        bytes newCommitment =
            c.split(1)[0] +
            0x00 +
            c.split(2)[1].split(3)[0] +
            toPaddedBytes(newPeriodId, 4) +
            toPaddedBytes(newSpent, 8) +
            toPaddedBytes(tx.locktime, 8) +
            0x0000000000000000000000000000;

        require(tx.outputs[1].nftCommitment == newCommitment);
        require(tx.outputs[1].tokenCategory == tx.inputs[0].tokenCategory);
        require(tx.outputs[1].lockingBytecode == tx.inputs[0].lockingBytecode);
        require(proposalId != 0x0000000000000000000000000000000000000000000000000000000000000000);
    }

    /**
     * pause() — Any registered signer can pause the vault
     */
    function pause(sig authSig, pubkey authPubkey) {
        bytes c = tx.inputs[0].nftCommitment;
        int status = int(c.split(1)[1].split(1)[0]);

        bytes20 pkHash = hash160(authPubkey);
        require(pkHash == signer1Hash || pkHash == signer2Hash || pkHash == signer3Hash);
        require(checkSig(authSig, authPubkey));
        require(status == 0); // ACTIVE

        bytes newCommitment = c.split(1)[0] + 0x01 + c.split(2)[1].split(30)[0];
        require(tx.outputs[0].nftCommitment == newCommitment);
        require(tx.outputs[0].tokenCategory == tx.inputs[0].tokenCategory);
        require(tx.outputs[0].lockingBytecode == tx.inputs[0].lockingBytecode);
    }

    /**
     * resume() — Resume a paused vault (M-of-N required)
     */
    function resume(sig sig1, pubkey pubkey1, sig sig2, pubkey pubkey2) {
        bytes c = tx.inputs[0].nftCommitment;
        int status = int(c.split(1)[1].split(1)[0]);

        bytes20 pk1Hash = hash160(pubkey1);
        bytes20 pk2Hash = hash160(pubkey2);

        require(pk1Hash == signer1Hash || pk1Hash == signer2Hash || pk1Hash == signer3Hash);
        require(pk2Hash == signer1Hash || pk2Hash == signer2Hash || pk2Hash == signer3Hash);
        require(pk1Hash != pk2Hash);

        require(checkSig(sig1, pubkey1));
        require(checkSig(sig2, pubkey2));
        require(status == 1); // PAUSED

        bytes newCommitment = c.split(1)[0] + 0x00 + c.split(2)[1].split(30)[0];
        require(tx.outputs[0].nftCommitment == newCommitment);
        require(tx.outputs[0].tokenCategory == tx.inputs[0].tokenCategory);
        require(tx.outputs[0].lockingBytecode == tx.inputs[0].lockingBytecode);
    }

    /**
     * emergencyLock() — Full lockdown requiring ALL 3 registered signers
     */
    function emergencyLock(
        sig sig1, pubkey pubkey1,
        sig sig2, pubkey pubkey2,
        sig sig3, pubkey pubkey3
    ) {
        bytes c = tx.inputs[0].nftCommitment;
        int status = int(c.split(1)[1].split(1)[0]);

        require(hash160(pubkey1) == signer1Hash);
        require(hash160(pubkey2) == signer2Hash);
        require(hash160(pubkey3) == signer3Hash);

        require(checkSig(sig1, pubkey1));
        require(checkSig(sig2, pubkey2));
        require(checkSig(sig3, pubkey3));

        require(status == 0 || status == 1); // ACTIVE or PAUSED

        bytes newCommitment = c.split(1)[0] + 0x02 + c.split(2)[1].split(30)[0];
        require(tx.outputs[0].nftCommitment == newCommitment);
        require(tx.outputs[0].tokenCategory == tx.inputs[0].tokenCategory);
        require(tx.outputs[0].lockingBytecode == tx.inputs[0].lockingBytecode);
        require(vaultId != 0x0000000000000000000000000000000000000000000000000000000000000000);
        require(requiredApprovals > 0);
    }
}
