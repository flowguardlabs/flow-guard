/**
 * ProposalCovenant — Production Grade
 *
 * ENFORCEABILITY: [ENFORCEABLE-NOW]
 *
 * PURPOSE: Manage spending proposal lifecycle
 * - Track M-of-N approvals with signer identity validation
 * - Enforce status transitions (PENDING → APPROVED → EXECUTED)
 * - Enforce execution timelock (CLTV)
 * - Cancel by M-of-N, expire after voting deadline
 *
 * NFT COMMITMENT (40 bytes — within CashTokens 40-byte limit):
 *   [0]:     version (uint8)
 *   [1]:     status (uint8: 0=PENDING, 1=APPROVED, 2=EXECUTED, 3=CANCELLED, 4=EXPIRED)
 *   [2]:     approval_bitmask (uint8: bit0=signer1, bit1=signer2, bit2=signer3)
 *   [3]:     required_approvals (uint8)
 *   [4-8]:   voting_end_timestamp (5 bytes)
 *   [9-13]:  execution_timelock (5 bytes)
 *   [14-33]: payout_hash (bytes20)
 *   [34-39]: reserved
 *
 * CONTRACT PARAMETERS (compiled into bytecode, immutable):
 *   vaultId           — links proposal to vault
 *   signer1Hash       — hash160 of vault signer 1
 *   signer2Hash       — hash160 of vault signer 2
 *   signer3Hash       — hash160 of vault signer 3
 *   requiredApprovals — M in M-of-N
 */

pragma cashscript ^0.13.0;

contract ProposalCovenant(
    bytes32 vaultId,
    bytes20 signer1Hash,
    bytes20 signer2Hash,
    bytes20 signer3Hash,
    int requiredApprovals
) {
    /**
     * approve() — Vault signer adds their approval
     *
     * Uses a per-signer bitmask to prevent the same signer from
     * voting twice and self-approving a proposal alone.
     */
    function approve(sig approverSig, pubkey approverPubkey) {
        bytes c = tx.inputs[0].nftCommitment;
        int status          = int(c.split(1)[1].split(1)[0]);
        bytes1 approvalMask = c.split(2)[1].split(1)[0];

        bytes20 pkHash = hash160(approverPubkey);
        require(pkHash == signer1Hash || pkHash == signer2Hash || pkHash == signer3Hash);
        require(checkSig(approverSig, approverPubkey));
        require(status == 0); // PENDING

        // Map signer to their bit in the approval mask
        bytes1 signerBit = 0x00;
        if (pkHash == signer1Hash) { signerBit = 0x01; }
        if (pkHash == signer2Hash) { signerBit = 0x02; }
        if (pkHash == signer3Hash) { signerBit = 0x04; }

        // Reject if this signer has already approved
        require((approvalMask & signerBit) == 0x00);

        // Set signer's bit (safe: addition == OR when the bit was 0)
        int newMask = int(approvalMask) + int(signerBit);

        // Count total approvers after this vote
        int approvalCount = 0;
        if ((approvalMask & 0x01) == 0x01) { approvalCount = approvalCount + 1; }
        if ((approvalMask & 0x02) == 0x02) { approvalCount = approvalCount + 1; }
        if ((approvalMask & 0x04) == 0x04) { approvalCount = approvalCount + 1; }
        approvalCount = approvalCount + 1; // include this vote

        int newStatus = 0;
        if (approvalCount >= requiredApprovals) { newStatus = 1; } // APPROVED

        bytes newCommitment =
            c.split(1)[0] +
            toPaddedBytes(newStatus, 1) +
            toPaddedBytes(newMask, 1) +
            c.split(3)[1].split(31)[0] +
            0x000000000000;

        require(tx.outputs[0].nftCommitment == newCommitment);
        require(tx.outputs[0].tokenCategory == tx.inputs[0].tokenCategory);
        require(tx.outputs[0].lockingBytecode == tx.inputs[0].lockingBytecode);
    }

    /**
     * execute() — Execute an approved proposal
     *
     * ProposalNFT is burned after execution.
     */
    function execute() {
        bytes c = tx.inputs[0].nftCommitment;
        int status            = int(c.split(1)[1].split(1)[0]);
        int executionTimelock = int(c.split(9)[1].split(5)[0]);

        require(status == 1); // APPROVED
        require(tx.locktime >= executionTimelock);
        require(vaultId != 0x0000000000000000000000000000000000000000000000000000000000000000);
    }

    /**
     * cancel() — Cancel a pending or approved proposal (M-of-N)
     */
    function cancel(sig sig1, pubkey pubkey1, sig sig2, pubkey pubkey2) {
        bytes c = tx.inputs[0].nftCommitment;
        int status = int(c.split(1)[1].split(1)[0]);

        bytes20 pk1Hash = hash160(pubkey1);
        bytes20 pk2Hash = hash160(pubkey2);

        require(pk1Hash == signer1Hash || pk1Hash == signer2Hash || pk1Hash == signer3Hash);
        require(pk2Hash == signer1Hash || pk2Hash == signer2Hash || pk2Hash == signer3Hash);
        require(pk1Hash != pk2Hash);

        require(checkSig(sig1, pubkey1));
        require(checkSig(sig2, pubkey2));

        require(status == 0 || status == 1); // PENDING or APPROVED

        bytes newCommitment =
            c.split(1)[0] +
            0x03 +
            c.split(2)[1].split(32)[0] +
            0x000000000000;

        require(tx.outputs[0].nftCommitment == newCommitment);
        require(tx.outputs[0].tokenCategory == tx.inputs[0].tokenCategory);
        require(tx.outputs[0].lockingBytecode == tx.inputs[0].lockingBytecode);
    }

    /**
     * expire() — Mark proposal expired after voting deadline (permissionless)
     */
    function expire() {
        bytes c = tx.inputs[0].nftCommitment;
        int status    = int(c.split(1)[1].split(1)[0]);
        int votingEnd = int(c.split(4)[1].split(5)[0]);

        require(status == 0); // PENDING
        require(votingEnd > 0);
        require(tx.locktime >= votingEnd);

        bytes newCommitment =
            c.split(1)[0] +
            0x04 +
            c.split(2)[1].split(32)[0] +
            0x000000000000;

        require(tx.outputs[0].nftCommitment == newCommitment);
        require(tx.outputs[0].tokenCategory == tx.inputs[0].tokenCategory);
        require(tx.outputs[0].lockingBytecode == tx.inputs[0].lockingBytecode);
    }
}
